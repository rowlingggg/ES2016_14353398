
#                                                   LAB4实验报告
##lab4：Deadlock死锁

###实验任务
1. 死锁停在第几次的截图
2. 产生死锁的4个必要条件
3. 对上述程序产生死锁的解释







###实验步骤


1. 将Deadlock.java代码打好放在learngit文件夹-->assignment4文件夹中
 * ![]()

2. 运行代码
  # `javac Deadlock.java`
   #`#!/bin/bash`
 * ![]()
 * ![]()

3. 修改deadlock.java中的count=10000，然后for循环中的次数改为1000，得到运行结果，停在了第5次
   * ![]() 



***
####死锁产生的4个必要条件

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系



***
***
###对上述产生死锁的解释
对于deadlock中的synchronized代码，可以知道它是当修饰Aclass或者Bclass时，保证同一时间只有一个进程（线程）在执行，当有其他进程请求访问时将会被阻塞。
count=10000或者20000为计时，c循环运行100次或者1000次实际上就是在不断地进行线程的创建和执行，而停止的过程是随机的，当且在上一个线程还在执行，下一个进程恰好结束了等待，继而产生死锁。


















